---
layout: post
title: "「数据结构与算法」-时间复杂度"
subtitle: "时间复杂度总结"
date: 2019-10-17 12:00:00
author: "ldb"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
 - 数据结构
 - 算法
---

# **概念**

时间复杂度用大O表示，通常去掉公式中的低阶、常量、系数，只需要记录一个最大量级就可以了。

例：

> T(n) = O(2n +2n+3)  ，n表示数据增长变化趋势。 时间复杂度记为O(n)
>
> T(n) = O(2n^2+2n+3),  时间复杂度记为O(n^2)



# **时间复杂度分析三原则**

-  只关注循环执行次数最多的一段代码
-  加法法则：总复杂度等于量级最大的那段代码的复杂度
-  乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

也就是说，假设 T1(n) = O(n) ， T2(n) = O(n^2 ) ，则 T1(n) * T2(n) = O(n^3 ) 。



# **常用数据结构与算法时间复杂度**

## 数组

随机访问O(1)

插入，删除O(n)

无序数组插入可以实现O(1)。



## 链表

插入，删除    O(1)

查找    O(n)



## 栈

入栈、出栈的时间复杂度都为 O(1)，当空间不够时，就需要重新申请内存和数据搬移，所以时间复杂度就变成了 O(n)



## 队列

入队，出队时间复杂度都为 O(1)，平均时间复杂度O(1)



## 排序

**1，冒泡，插入，选择  平均时间复杂度    O(n)**



**2，归并排序分析**

T(1) = C ； n=1  时，只需要常量级的执行时间，所以表示为 C 。

T(n) = 2*T(n/2) + n ； n>1



T(n)  = 2*T(n/2) + n

= 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n

= 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n

= 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n

......

= 2^k * T(n/2^k) + k * n

T(n/2^k)=T(1)  时，也就是n/2^k=1 ，我们得到 k=log n  。



我们将 k  值代入上面的公式，得到 T(n)=Cn+nlog n  。如果我们用大 O标记法来表示的话， T(n)  就等于 O(nlogn) 。所以归并排序的时间复杂度是 O(nlogn) 。



**3，快速排序分析**

时间复杂度递推求解公式跟归并是相同的。所以，快排的时间复杂度也是 O(nlogn) 。但是如果pivot选择不好，分区不能一分为二，快排的时间复杂度就从 O(nlogn)  退化成了 O(n2) 。



**4，线性排序**

计数排序    O(n+k)  k是数据范围

桶排序       O(n)

基数排序    O(dn)   d是维度



## 二分查找         O(logn)

## 跳表                O(logn)

## 散列表         

插入，删除，查找O(1),  扩容时为O(n),散列冲突时，链表长度为k ，O(k)

## 二叉搜索树

时间复杂度其实都跟树的高度成正比，也就是 O(height) 。

对完全二叉树来说，有L层：

n >= 1+2+4+8+...+2^(L-2)+1

n <= 1+2+4+8+...+2^(L-2)+2^(L-1)

算出： L  的范围是 [log (n+1), log n +1]



完全二叉树的层数小于等于 log n +1 ，也就是说，完全二叉树的高度小于等于 log n 。

平衡二叉查找树的高度接近logn ，所以插入、删除、查找操作的时间复杂度也比较稳定，是 O(logn)

红黑树是一个平衡二叉查找树    O(logn)



**未完...**